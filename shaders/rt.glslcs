#version 460 core

layout(binding = 0, rgba32f) uniform image2D framebuffer;

struct Camera{
    vec3 pos;
    vec3 dir;
    vec3 yAxis;
    vec3 xAxis;
    float tanFovY;
    float tanFovX;
};

struct Cube {
    mat4 transMat;
    vec4 min;
    vec4 max;
};

struct Object{
    Cube c;
    int material_index;
};

struct hitinfo {
    vec3    normal;
    float   intersection_dist;
    int     box_index;
};

struct planeinfo {
    int     ax_index;
    float   e;
    float   f;
    float   tMin;
    float   tMax;
};

struct Ray{
    vec3 origin;
    vec3 dir;
};

//attenuation.w : 1 = Point light; 2 = Directional light
struct Light{
    vec4 pos_dir;
    vec4 color;
    vec4 attenuation;
};

struct Material{
    vec4 diffuse;
    vec4 specularity;
    vec4 emission;
    float shininess;
};

layout(std430) buffer PrimitiveBuffer{
    Object objects[];
};

layout(std430) buffer MaterialBuffer{
    Material materials[];
};

layout(std430) buffer LightBuffer{
    Light lights[];
};

// The camera specification
uniform Camera camera;
uniform uint width;
uniform uint height;

#define FAR_CLIP 100.0
#define NUM_BOXES 2
#define NUM_LIGHTS 1

// Initialize the primary ray for pixel x, y
Ray initRay(uint x, uint y)
{
    float halfWidth = float(width) / 2.0f;
    float halfHeight = float(height) / 2.0f;

    float a = camera.tanFovX * ((float(x) - halfWidth + 0.5f) / halfWidth);
    float b = camera.tanFovY * ((halfHeight - float(y) - 0.5f) / halfHeight);

    vec3 dir = normalize((a * camera.xAxis + b * camera.yAxis + camera.dir).xyz);

    return Ray(camera.pos.xyz, dir);
}

float fabs(float f) {
    return (f > 0 ? f : -f);
}

bool intersectPlanes(const vec3 axis, int box_index, inout planeinfo p_info, out vec3 normal) {
	// Test intersection between ray and the 2 planes perpendicular to one OBB axis
    float swapped = 1.f;
    Cube c = objects[box_index].c;

    if (fabs(p_info.f) > 0.001f) {
        float t1 = (p_info.e + c.min[p_info.ax_index])/p_info.f; // Intersection with "left" (for xaxis) plane
        float t2 = (p_info.e + c.max[p_info.ax_index])/p_info.f; // Intersection with "right" (for xaxis) plane
        // We want t1 to be nearest intersection, so if it's not, invert t1 and t2
        if (t1 > t2) {
            float tmp = t1;
            t1 = t2;
            t2 = tmp;
            swapped = -1.f; // Used to invert the normal (~ choose opposite cube face)
        }

        p_info.tMax = t2 < p_info.tMax ? t2 : p_info.tMax; // Tmax = nearest "far" intersection
        if (t1 > p_info.tMin) { // Tmin = farthest "near" intersection
            p_info.tMin = t1;
            normal = (swapped * axis);
        }

        // The trick : if "far" is closer than "near", then there is NO intersection.
        if (p_info.tMax < p_info.tMin)
            return false;
    }
    else if(-p_info.e + c.min[p_info.ax_index] > 0.0f ||
                -p_info.e + c.max[p_info.ax_index] < 0.0f) {
        // Rare case : the ray is almost parallel to the planes, so they don't have any "intersection"
        return false;
    }
    return true;
}

bool intersectBox(Ray r, int box_index, out float intersection_dist, out vec3 normal) {
    // https://www.opengl-tutorial.org/miscellaneous/clicking-on-objects/picking-with-custom-ray-obb-function/
    Cube c = objects[box_index].c;
    // 4th vector in a transformation matrix is translation vector, here the center
    vec3 center = {c.transMat[3].x, c.transMat[3].y, c.transMat[3].z};
    planeinfo p_info = {0, 0.f, 0.f, 0.f, 100000.0f};

    for (int ax_index = 0; ax_index < 3; ax_index++) {
        vec3 axis = {c.transMat[0][ax_index], c.transMat[1][ax_index], c.transMat[2][ax_index]};
        p_info.e = dot(axis, center - r.origin); // Projection of (center - ray_orig) on axis
        p_info.f = dot(axis, r.dir); // Projection of ray on axis
        p_info.ax_index = ax_index;
        if (!intersectPlanes(axis, box_index, p_info, normal))
            return false;
    }

	intersection_dist = p_info.tMin;
    return true;
}

hitinfo intersectBoxes(Ray r) {
    vec3    normal;
    float   intersection_dist;
    hitinfo h_info = {vec3(0.f), FAR_CLIP, NUM_BOXES};

    for (int box_index = 0; box_index < NUM_BOXES; box_index++) {
        if (intersectBox(r, box_index, intersection_dist, normal)
            && intersection_dist < h_info.intersection_dist) {
            h_info.intersection_dist = intersection_dist;
            h_info.box_index = box_index;
            h_info.normal = normal;
        }
    }
    return h_info;
}

vec4 trace(Ray r) {
    hitinfo h_info = intersectBoxes(r);

    if (h_info.box_index != NUM_BOXES) {
        vec4 gray = vec4(h_info.box_index / 10.0 + 0.8);
        return vec4(gray.rgb, 1.0);
    }
    return vec4(0.0, 0.0, 0.0, 1.0);
}

layout (local_size_x = 16, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
    Ray r = initRay(pix.x, pix.y);
    vec4 color = trace(r);
    imageStore(framebuffer, pix, color);
}