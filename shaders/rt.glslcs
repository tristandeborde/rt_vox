#version 460 core

layout(binding = 0, rgba32f) uniform image2D framebuffer;

struct Camera{
    vec3 pos;
    vec3 dir;
    vec3 yAxis;
    vec3 xAxis;
    float tanFovY;
    float tanFovX;
};

struct box {
    vec3 min;
    vec3 max;
    mat4 transMat;
};

const box boxes[] = {
    /* The ground */
    {vec3(-5.0, -0.1, -5.0), vec3(5.0, 0.0, 5.0), mat4(1.0)},
    /* box in the middle */
    {vec3(-0.5, 0.0, -0.5), vec3(0.5, 1.0, 0.5), mat4(1.0)}
};

struct hitinfo {
  float intersection_dist;
  int   bi;
};

// The camera specification
uniform Camera camera;
uniform uint width;
uniform uint height;

#define MAX_SCENE_BOUNDS 100.0
#define NUM_BOXES 2

// Initialize the primary ray for pixel x, y
vec3 initRay(uint x, uint y)
{
    float halfWidth = float(width) / 2.0f;
    float halfHeight = float(height) / 2.0f;

    float a = camera.tanFovX * ((float(x) - halfWidth + 0.5f) / halfWidth);
    float b = camera.tanFovY * ((halfHeight - float(y) - 0.5f) / halfHeight);

    vec3 dir = normalize((a * camera.xAxis + b * camera.yAxis + camera.dir).xyz);

    return dir;
}

float fabs(float f) {
    return (f > 0 ? f : -f);
}

bool intersectBox(vec3 ray_origin, vec3 ray_dir, const box b, inout float intersection_dist) {
    // 4th vector in a transformation matrix is translation vector, here the center
    vec3 center = {b.transMat[3].x, b.transMat[3].y, b.transMat[3].z};
    vec3 delta = center - ray_origin;
    float tMin = 0.0f;
    float tMax = 100000.0f;

    vec3 xaxis = {b.transMat[0].x, b.transMat[0].y, b.transMat[0].z};
    float e = dot(xaxis, delta);
    float f = dot(xaxis, ray_dir);

    if ( fabs(f) > 0.001f ) { // Standard case
        float t1 = (e + b.min.x)/f; // Intersection with the "left" plane
        float t2 = (e + b.max.x)/f; // Intersection with the "right" plane
        // t1 and t2 now contain distances between ray origin and ray-plane intersections

        // We want t1 to represent the nearest intersection, 
        // so if it's not the case, invert t1 and t2
        if (t1>t2) {
            float w=t1;t1=t2;t2=w; // swap t1 and t2
        }

        // tMax is the nearest "far" intersection (amongst the X,Y and Z planes pairs)
        tMax = t2 < tMax ? t2 : tMax;
        // tMin is the farthest "near" intersection (amongst the X,Y and Z planes pairs)
        tMin = t1 > tMin ? t1 : tMin;

        // And here's the trick :
        // If "far" is closer than "near", then there is NO intersection.
        if (tMax < tMin)
            return false;
    } 
    else { // Rare case : the ray is almost parallel to the planes, so they don't have any "intersection"
        if(-e+b.min.x > 0.0f || -e+b.max.x < 0.0f)
            return false;
    }

	// Test intersection with the 2 planes perpendicular to the OBB's Y axis
    vec3 yaxis = {b.transMat[1].x, b.transMat[1].y, b.transMat[1].z};
    e = dot(yaxis, delta);
    f = dot(ray_dir, yaxis);

    if ( fabs(f) > 0.001f ){
        float t1 = (e+b.min.y)/f;
        float t2 = (e+b.max.y)/f;

        if (t1>t2){float w=t1;t1=t2;t2=w;}

        tMax = t2 < tMax ? t2 : tMax;
        tMin = t1 > tMin ? t1 : tMin;

        if (tMax < tMin )
            return false;
    }
    else {
        if(-e+b.min.y > 0.0f || -e+b.max.y < 0.0f)
            return false;
    }

	// Test intersection with the 2 planes perpendicular to the OBB's Z axis
    vec3 zaxis = {b.transMat[2].x, b.transMat[2].y, b.transMat[2].z};
    e = dot(zaxis, delta);
    f = dot(ray_dir, zaxis);

    if ( fabs(f) > 0.001f ) {
        float t1 = (e+b.min.z)/f;
        float t2 = (e+b.max.z)/f;

        if (t1>t2){float w=t1;t1=t2;t2=w;}

        tMax = t2 < tMax ? t2 : tMax;
        tMin = t1 > tMin ? t1 : tMin;

        if (tMax < tMin )
            return false;
    }
    else {
        if(-e+b.min.z > 0.0f || -e+b.max.z < 0.0f)
            return false;
    }

	intersection_dist = tMin;
    return true;
}

bool intersectBoxes(vec3 origin, vec3 dir, out hitinfo info) {
    float smallest = MAX_SCENE_BOUNDS;
    bool found = false;
    for (int i = 0; i < NUM_BOXES; i++) {
        float intersection_dist = 0.f;
        if (intersectBox(origin, dir, boxes[i], intersection_dist)
            && intersection_dist < smallest) {
            info.intersection_dist = intersection_dist;
            info.bi = i;
            smallest = intersection_dist;
            found = true;
        }
    }
    return found;
}

vec4 trace(vec3 origin, vec3 dir) {
    hitinfo i;
    if (intersectBoxes(origin, dir, i)) {
        vec4 gray = vec4(i.bi / 10.0 + 0.8);
        return vec4(gray.rgb, 1.0);
    }
    return vec4(0.0, 0.0, 0.0, 1.0);
}

layout (local_size_x = 16, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
    vec3 ray = initRay(pix.x, pix.y);
    vec4 color = trace(camera.pos, ray);
    imageStore(framebuffer, pix, color);
}